(A)

Fission: a Serverless Framework on Kubernetes
---------------------------------------------

"Serverless" functions allow users to easily create services from
source code without dealing with the packaging, deployment, scaling,
etc.

Fission is a serverless function framework built on Kubernetes.  Users
write functions and map them to HTTP routes.  They don't have to deal
with container images, registries or even learn Kubernetes in much
detail.

Functions can be associated with HTTP routes, events, or timers.
Functions consume CPU and memory resources only when running; they are
started on-demand and killed when idle.  Fission makes on-demand
function loading very fast, by keeping an idle pool of containers
running, in effect creating a distributed "threadpool".

Fission is useful for:
 * Creating web app backends or REST APIs
 * Implementing webhooks
 * Writing event handlers 

We'll demo the creation of a simple web app using fission functions in
Python.  We'll also cover:

 * Unit testing and integration testing of functions
 * Function versioning
 * Logging, metrics, tracing
 * Extensibility -- how to add arbitrary dependencies

We'll also show how tying together Kubernetes Watches and Fission
functions make it very easy to write custom behaviour triggered by
changes to arbitrary resources on Kubernetes.



(B)

Building Serverless Controllers with Kubernetes Watches and Fission
-------------------------------------------------------------------

Kubernetes is based on a pattern of declarative infrastructure: the
user declares what they want by specifying a _resource_, and a
_Controller_ continually ensures that the state of the system meets
the specification.

Controllers such as Deployments, ReplicaSets, StatefulSet etc enable a
wide variety of use cases.  But some workloads need custom, domain
specific logic in their controllers.

Kubernetes can be extended by creating Third Party Resources and
custom Controllers, however, creating a custom controller has a
learning curve and can be cumbersome.

The Fission serverless framework can be used to attach functions to
Kubernetes watch events.  In other words, whenever there's a change to
a set of objects, a user's custom function can be called with details
about the change.  By watching a third party resource, a user can
create a custom controller in Python, NodeJS, etc. for their custom
workload.

In this talk, we'll use a MySQL high availability deployment on
Kubernetes as an example, and show a proof of concept of how
Kubernetes and Serverless Controllers can make it easy to deploy,
upgrade, scale, and monitor such a system with a minimal amount of
code.



(C)

A deep dive into Kubernetes Watches
-----------------------------------

How does 'kubectl --watch' work?  What order do watch updates arrive
in?  Do watch events ever get "lost"?  How should I process watches?

Understanding how watches work is essential to extending Kubernetes.
In this talk we'll examine the behaviour of watches, their
implementation in Kubernetes, and review what information is available
to consumers of a watch.

We'll talk about:

* How to process watches in Go with the client-go library

* Using a message queue to make watches more reliable; pros and cons
  of this approach.

* How to turn watches into webhook requests with the `kubewatcher`
  service
