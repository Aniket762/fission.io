[
{
	"uri": "http://fission.io/docs/0.5.0/compilation/",
	"title": "Compiling Fission",
	"tags": [],
	"description": "",
	"content": "[You only need to do this if you\u0026rsquo;re making Fission changes; if you\u0026rsquo;re just deploying Fission, use fission.yaml which points to prebuilt images.]\nYou\u0026rsquo;ll need the go compiler and tools installed, along with the glide dependency management tool. You\u0026rsquo;ll also need docker for building images.\nThe server side is compiled as one binary (\u0026ldquo;fission-bundle\u0026rdquo;) which contains controller, poolmgr and router; it invokes the right one based on command-line arguments.\nTo build fission-bundle: clone this repo to $GOPATH/src/github.com/fission/fission, then from the top level directory (if you want to build the image with the docker inside minikube, you\u0026rsquo;ll need to set the proper environment variables with eval $(minikube docker-env)):\n # Get dependencies $ glide install # Build fission server and an image $ pushd fission-bundle $ ./build.sh  You now need to build the docker image for fission. You can use push.sh and push it to a docker hub account. But it\u0026rsquo;s easiest to use minikube and its built-in docker daemon:\n $ eval $(minikube docker-env) $ docker build -t minikube/fission-bundle .  Next, install fission with this image on your kubernetes cluster using the helm chart:\n $ helm install --set \u0026quot;image=minikube/fission-bundle,pullPolicy=IfNotPresent,analytics=false\u0026quot; charts/fission-all  And if you\u0026rsquo;re changing the CLI too, you can build it with:\n # Build Fission CLI $ cd fission \u0026amp;\u0026amp; go install  "
},
{
	"uri": "http://fission.io/docs/0.5.0/",
	"title": "Fission",
	"tags": [],
	"description": "",
	"content": " Fission: Serverless Functions for Kubernetes fission.io @fissionio\nFission is a fast serverless framework for Kubernetes with a focus on developer productivity and high performance.\nFission operates on just the code: Docker and Kubernetes are abstracted away under normal operation, though you can use both to extend Fission if you want to.\nFission is extensible to any language; the core is written in Go, and language-specific parts are isolated in something called environments (more below). Fission currently supports NodeJS, Python, Ruby, Go, PHP, Bash, and any Linux executable, with more languages coming soon.\nPerformance: 100msec cold start Fission maintains a pool of \u0026ldquo;warm\u0026rdquo; containers that each contain a small dynamic loader. When a function is first called, i.e. \u0026ldquo;cold-started\u0026rdquo;, a running container is chosen and the function is loaded. This pool is what makes Fission fast: cold-start latencies are typically about 100msec.\nKubernetes is the right place for Serverless We\u0026rsquo;re built on Kubernetes because we think any non-trivial app will use a combination of serverless functions and more conventional microservices, and Kubernetes is a great framework to bring these together seamlessly.\nBuilding on Kubernetes also means that anything you do for operations on your Kubernetes cluster \u0026mdash; such as monitoring or log aggregation \u0026mdash; also helps with ops on your Fission deployment.\nFission Concepts A function is a piece of code that follows the fission function interface.\nAn environment contains the language- and runtime-specific parts of running a function.\nThe following environments are currently available:\n   Environment Image     Binary (for executables or scripts) fission/binary-env   Go fission/go-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Perl fission/perl-env   PHP 7 fission/php-env   Python 3 fission/python-env   Ruby fission/ruby-env    You can also extend environments or create entirely new ones if you want. (An environment is essentially just a container with a webserver and dynamic loader.)\nA trigger is something that maps an event to a function; Fission supports HTTP routes as triggers today, with upcoming support for other types of event triggers, such as timers and Kubernetes events.\nUsage # Add the stock NodeJS env to your Fission deployment $ fission env create --name nodejs --image fission/node-env # A javascript one-liner that prints \u0026quot;hello world\u0026quot; $ curl https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js \u0026gt; hello.js # Upload your function code to fission $ fission function create --name hello --env nodejs --code hello.js # Map GET /hello to your new function $ fission route create --method GET --url /hello --function hello # Run the function. This takes about 100msec the first time. $ curl http://$FISSION_ROUTER/hello Hello, world!  See the examples directory for more.\n"
},
{
	"uri": "http://fission.io/docs/0.5.0/prerequisite/",
	"title": "Kubernetes Quick Install",
	"tags": [],
	"description": "",
	"content": " This is a quick guide to help you get started running Kubernetes on your laptop (or on the cloud).\n(This isn\u0026rsquo;t meant as a production Kuberenetes guide; it\u0026rsquo;s merely intended to give you something quickly so you can try Fission on it.)\nMinikube Minikube is the usual way to run Kubernetes on your laptop:\nInstall and start Kubernetes on OSX: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.16.0/minikube-darwin-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Or, install and start Kubernetes on Linux: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.16.0/minikube-linux-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Google Container Engine Alternatively, you can use Google Container Engine\u0026rsquo;s free trial to get a 3-node cluster. Hop over to Google Cloud to set that up.\n"
},
{
	"uri": "http://fission.io/docs/0.5.0/installation/",
	"title": "Installation Guide",
	"tags": [],
	"description": "",
	"content": " Welcome! This guide will get you up and running with Fission on a Kubernetes cluster.\nCluster preliminaries If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up.\nLet\u0026rsquo;s ensure you have the Kubernetes CLI and Helm installed and ready. If you already have helm, skip ahead to the fission install.\nKubernetes CLI Ensure you have the Kubernetes CLI.\nYou can get the Kubernetes CLI for OSX like this:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Or, for Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Ensure you have access to a cluster; use kubectl to check your Kubernetes version:\n$ kubectl version  We need at least Kubernetes 1.6 (older versions may work, but we don\u0026rsquo;t test them).\nHelm Helm is an installer for Kubernetes. If you already use helm, skip to the next section.\nFirst, you\u0026rsquo;ll need the helm CLI:\nOn OS X:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-darwin-amd64.tar.gz $ tar xzf helm-v2.7.0-darwin-amd64.tar.gz $ mv darwin-amd64/helm /usr/local/bin  On Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-linux-amd64.tar.gz $ tar xzf helm-v2.7.0-linux-amd64.tar.gz $ mv linux-amd64/helm /usr/local/bin  Next, install the Helm server on your Kubernetes cluster:\n$ helm init  Install Fission Minikube $ helm install --namespace fission --set serviceType=NodePort https://github.com/fission/fission/releases/download/0.5.0/fission-all-0.5.0.tgz  The serviceType variable allows configuring the type of Kubernetes service outside the cluster. You can use ClusterIP if you don\u0026rsquo;t want to expose anything outside the cluster.\nCloud hosted clusters (GKE, AWS, Azure etc.) $ helm install --namespace fission https://github.com/fission/fission/releases/download/0.5.0/fission-all-0.5.0.tgz  Minimal version The fission-all helm chart installs a full set of services including the NATS message queue, influxDB for logs, etc. If you want a more minimal setup, you can install the fission-core chart instead:\n$ helm install --namespace fission https://github.com/fission/fission/releases/download/0.5.0/fission-core-0.5.0.tgz  Install the Fission CLI OS X Get the CLI binary for Mac:\n$ curl -Lo fission https://github.com/fission/fission/releases/download/0.5.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.5.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nSet environment vars Set the FISSION_URL and FISSION_ROUTER environment variables. FISSION_URL is used by the fission CLI to find the server. (FISSION_ROUTER is only needed for the examples below to work.)\nMinikube If you\u0026rsquo;re using minikube, use these commands:\n $ export FISSION_URL=http://$(minikube ip):31313 $ export FISSION_ROUTER=$(minikube ip):31314  Cloud setups Save the external IP addresses of controller and router services in FISSION_URL and FISSION_ROUTER, respectively. Wait for services to get IP addresses (check this with kubectl --namespace fission get svc). Then:\nAWS  $ export FISSION_URL=http://$(kubectl --namespace fission get svc controller -o=jsonpath='{..hostname}') $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..hostname}')  GCP  $ export FISSION_URL=http://$(kubectl --namespace fission get svc controller -o=jsonpath='{..ip}') $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..ip}')  Run an example Finally, you\u0026rsquo;re ready to use Fission!\n$ fission env create --name nodejs --image fission/node-env:0.5.0 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js $ fission function create --name hello --env nodejs --code hello.js $ fission route create --method GET --url /hello --function hello $ curl http://$FISSION_ROUTER/hello Hello, world!  What\u0026rsquo;s next? If something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\nCheck out the examples for some example functions.\n"
},
{
	"uri": "http://fission.io/docs/0.5.0/upgrade/",
	"title": "Upgrade",
	"tags": [],
	"description": "",
	"content": " From v0.4.x to v0.5.0  Upgrade guide  From v0.3 to v0.4.x  Upgrade guide  From v0.1 to v0.2.x  Upgade guide  "
},
{
	"uri": "http://fission.io/docs/0.5.0/upgrade/upgrade-from-v0.1/",
	"title": "Upgrading from v0.1 to v0.2.x",
	"tags": [],
	"description": "",
	"content": " TL;DR The Fission API has changed significantly in this version. The new API is incompatible with the old one. The CLI is compatible; if you wrote scripts using it, those should still work.\nBelow we describe a tool for migrating your state from your old install to the new one.\nWhile this upgrade is going to be disruptive, we\u0026rsquo;re going to do our best to make sure future upgrades aren\u0026rsquo;t as bad.\nWhy is this so complicated? For a couple of reasons, we wanted to switch to using Kubernetes resources (ThirdPartyResources now, CustomResources in the next release) for storing Fission state: (a) it would allow users to avoid management of another database and (b) Fission would fit better into the Kubernetes ecosystem.\nConcurrently with this change, we were also trying to make our versioning approach less opinionated, so it would work with other tools.\nThirdly, we were also enabling build pipelines (v2 Environments).\nThese changes, especially the difference in versioning approach, made maintaining compatiblity not worth the effort at this early stage of the project.\nAll that said, we want you to know that we care a lot about compatiblity, and we\u0026rsquo;ll be more rigorous about it from the beta release onwards.\nHow to Upgrade  Get the v0.2.1 CLI Get the Fission state from your old install Install Fission v0.2.1 Restore Fission state into your new install Destroy your old install  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/v0.2.1-rc/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/v0.2.1-rc/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nGet Fission state from v0.1 install fission --server \u0026lt;your V1 server\u0026gt; upgrade dump --file state.json  You can skip the \u0026ndash;server argument if you have the environment variable $FISSION_URL set to point at a v0.1 Fission server.\nThis will create a JSON file with all your fission state in the current directory.\nInstall the new version Read the install guide. You can follow all of it, except that you will need to ensure your two installs don\u0026rsquo;t conflict. To do that, use separate namespaces and ensure nodeports don\u0026rsquo;t conflict. Install with a command similar to this:\nhelm install fission-all --namespace fission2 --set controllerPort=31303,routerPort=31304,natsStreamingPort=31305,functionNamespace=fission2-function  This installs fission in the fission2 namespace and runs functions in the fission2-function namespace.\nRestore your Fission state into Fission v0.2.1 fission upgrade restore --file state.json  This commands needs $FISSION_URL set to point to new fission installation.\nIt uses the file created in the first step. It doesn\u0026rsquo;t modify state.json.\n(Note that you can run this restore on any cluster; it doesn\u0026rsquo;t have the be the same kubernetes cluster as your old install.)\nVerify How exactly you do this is up to you! But, at a minimum, run fission fn list to check that all the functions you expect are there.\nSwitch over If you had exposed fission\u0026rsquo;s router to the outside world, switch over to using the new install\u0026rsquo;s router.\nDestroy your old install Once you\u0026rsquo;re no longer using the old install, you can destroy it by deleting the namespaces that was installed in.\nkubectl delete namespace fission fission-function  "
},
{
	"uri": "http://fission.io/docs/0.5.0/upgrade/upgrade-from-v0.3/",
	"title": "Upgrading from v0.3 to v0.4.x",
	"tags": [],
	"description": "",
	"content": " Introduction Kubernetes ThirdPartyResources (\u0026ldquo;TPR\u0026rdquo;) are replaced by CustomResourceDefinitions (\u0026ldquo;CRD\u0026rdquo;). TPRs have been deprecated and are removed in Kubernetes 1.8.\nSince Fission stores state in TPRs, we need to migrate this state from TPRs to CRDs while upgrading.\nFollow the instructions below if you\u0026rsquo;re upgrading a Fission 0.2.1 or 0.3.0 cluster to 0.4. If you\u0026rsquo;re using a pre-0.2 Fission cluster, use the [upgrade guide from 0.1 to 0.2]() and then upgrade to 0.4.0.\nHow to Upgrade  Get the 0.4.0 CLI Get the Fission state from v0.3 install Upgrade to Fission 0.4.0 Upgrade Kubernetes cluster version to 1.7.x or higher Remove all TPR definition (for Kubernetes 1.7.x) Restore Fission state into CRDs  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nGet Fission state from v0.3 install fission --server \u0026lt;your v0.3 server\u0026gt; tpr2crd dump --file state.json  You can skip the \u0026ndash;server argument if you have the environment variable $FISSION_URL set to point at a v0.3 Fission server.\nThis will create a JSON file with all your fission state in the current directory.\nUpgrade to Fission 0.4.0 Upgrade fission with a command similar to this:\nhelm upgrade fission-all --namespace fission  Upgrade Kubernetes cluster version Since CustomResource is only supported on Kubernetes v1.7+ and higher, please make sure that you upgrade to the right version that supports CustomResource.\nRemove all TPR definition (for Kubernetes 1.7.x) ** NOTICE **: This step will remove TPR definition from your kubernetes cluster. Please make sure that you dump all TPRs at the second step!\nThough Kubernetes will migrate TPRs to CRDs automatically when TPR definition is deleted if the same name CRD exists. We still need to make sure that there is no resource gets lost during the migration. Also, since we changed the capitalization of some CRDs to CamelCase (e.g. Httptrigger -\u0026gt; HTTPTrigger), we need to recreate those resources by ourselves.\nfission tpr2crd delete  Restore your Fission state into Fission 0.4.0 fission tpr2crd restore --file state.json  This commands needs $FISSION_URL set to point to new fission installation.\nIt uses the file created in the first step. It doesn\u0026rsquo;t modify state.json.\n(Note that you can run this restore on any cluster; it doesn\u0026rsquo;t have the be the same kubernetes cluster as your old install.)\nVerify Let\u0026rsquo;s check the migration result, first run following command to check CRD established state.\nkubectl get crd -o 'custom-columns=NAME:{.metadata.name},ESTABLISHED:{.status.conditions[?(@.type==\u0026quot;Established\u0026quot;)].status}'  The output should be like this\nNAME ESTABLISHED environments.fission.io True functions.fission.io True httptriggers.fission.io True kuberneteswatchtriggers.fission.io True messagequeuetriggers.fission.io True packages.fission.io True timetriggers.fission.io True  And check that CRD resources you expect are there.\nCOMMAND: fission [resource] list RESOURCES: environments functions httptriggers kuberneteswatchtriggers messagequeuetriggers packages timetriggers  "
},
{
	"uri": "http://fission.io/docs/0.5.0/upgrade/upgrade-from-v0.4/",
	"title": "Upgrading from v0.4.x to v0.5.0",
	"tags": [],
	"description": "",
	"content": " How to Upgrade  Get the 0.5.0 CLI Upgrade to Fission 0.5.0  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/0.5.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.5.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nUpgrade to Fission 0.5.0 Upgrade fission with a command similar to this:\n# find the release want to upgrade $ helm list # upgrade to 0.5.0 $ helm upgrade \u0026lt;release_name\u0026gt; https://github.com/fission/fission/releases/download/0.5.0/fission-all-0.5.0.tgz  "
},
{
	"uri": "http://fission.io/docs/0.5.0/tutorial/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": " Access Secret/ConfigMap In Function  "
},
{
	"uri": "http://fission.io/docs/0.5.0/tutorial/access-secret-cfgmap-in-function/",
	"title": "Access secret/configmap in function",
	"tags": [],
	"description": "",
	"content": " From fission v0.5.0 and later, functions are able to access Secrets and ConfigMaps specified by users.\nCreate Secret and ConfigMap You can create Secret and ConfigMap with CLI.\n$ kubectl -n default create secret generic foo --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot; $ kubectl -n default create configmap bar --from-literal=TEST_KEY=TESTVALUE  Or use kubectl create -f \u0026lt;filename.yaml\u0026gt; to create these from a YAML file.\napiVersion: v1 kind: Secret metadata: namespace: default name: foo data: TEST_KEY: VEVTVFZBTFVF # value after base64 encode type: Opaque --- apiVersion: v1 kind: ConfigMap metadata: namespace: default name: bar data: TEST_KEY: TESTVALUE  Access Secret and ConfigMap Since content of Secret and ConfigMap are key-value pairs, functions can access them with following paths:\n# Secret path /secrets/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt; # ConfigMap path /configs/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt;  From the previous example, the paths are:\n# secret foo /secrets/default/foo/TEST_KEY # confimap bar /configs/default/bar/TEST_KEY  Now, let\u0026rsquo;s create a simple python function (leaker.py) that return value of Secret foo and ConfigMap bar.\n# leaker.py def main(): path = \u0026quot;/configs/default/bar/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) config = f.read() path = \u0026quot;/secrets/default/foo/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) secret = f.read() msg = \u0026quot;ConfigMap: %s\\nSecret: %s\u0026quot; % (config, secret) return msg, 200  Create environment, function and http trigger.\n# create python env $ fission env create --name python --image fission/python-env # create function named \u0026quot;leaker\u0026quot; $ fission fn create --name leaker --env python --code leaker.py --secret foo --configmap bar # create route(http trigger) $ fission route create --function leaker --url /leaker --method GET  Try to access the function, the output should look like following.\n$ curl http://$FISSION_ROUTER/leaker ConfigMap: TESTVALUE Secret: TESTVALUE  Note: If the Secret or ConfigMap value is updated, the function may not get the updated value for some time; it may get a cached older value.\n"
},
{
	"uri": "http://fission.io/docs/0.5.0/workflows/",
	"title": "Workflows Installation Guide",
	"tags": [],
	"description": "",
	"content": " Prerequisites Fission Workflows requires the following components to be installed on your local machine:\n kubectl helm  Fission Workflows is deployed on top of a Kubernetes cluster. If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up. It also requires a Fission deployment to be present on your Kubernetes cluster. If you do not have a Fission deployment, follow Fission\u0026rsquo;s installation guide.\n(Note that Fission Workflows 0.2.0 requires Fission 0.4.1 or higher, with the NATS component installed!)\nInstalling Fission Workflows Fission Workflows is an add-on to Fission. You can install both Fission and Fission Workflows using helm charts.\nAssuming you have your Kubernetes cluster set up with a functioning deployment of Fission 0.4.1 or higher, run the following commands:\n# If you haven't already, add the Fission charts repo $ helm repo add fission-charts https://fission.github.io/fission-charts/ $ helm repo update # Install Fission Workflows $ helm install --wait -n fission-workflows fission-charts/fission-workflows --version 0.2.0  Creating your first workflow After installing Fission and Workflows, you\u0026rsquo;re all set to run a simple test workflow. With the following code snippet you will be able to deploy and run a small workflow example:\n# Fetch the required files, alternatively you could clone the fission-workflow repo $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.2.0/examples/whales/fortune.sh \u0026gt; fortune.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.2.0/examples/whales/whalesay.sh \u0026gt; whalesay.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.2.0/examples/whales/fortunewhale.wf.yaml \u0026gt; fortunewhale.wf.yaml # # Add binary environment and create two test functions on your Fission setup: # $ fission env create --name binary --image fission/binary-env $ fission function create --name whalesay --env binary --deploy ./whalesay.sh $ fission function create --name fortune --env binary --deploy ./fortune.sh # # Create a workflow that uses those two functions. A workflow is just # a function that uses the \u0026quot;workflow\u0026quot; environment. # $ fission function create --name fortunewhale --env workflow --src ./fortunewhale.wf.yaml # # Map an HTTP GET to your new workflow function: # $ fission route create --method GET --url /fortunewhale --function fortunewhale # # Invoke the workflow with an HTTP request: # $ curl ${FISSION_ROUTER}/fortunewhale  This last command, the invocation of the workflow, should return a whale saying something wise\n ______________________________________ / Anthony's Law of Force: \\ | | \\ Don't force it; get a larger hammer. / -------------------------------------- \\ \\ \\ ## . ## ## ## == ## ## ## ## ## === /\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\\___/ === { / ===- \\______ O __/ \\ \\ __/ \\____\\_______/  So what happened here? Let\u0026rsquo;s see what the workflow consists of (for example by running cat fortunewhale.wf.yaml):\n# This whale shows off a basic workflow that combines both Fission Functions (fortune, whalesay) and internal functions (noop) apiVersion: 1 output: WhaleWithFortune tasks: InternalFuncShowoff: run: noop GenerateFortune: run: fortune requires: - InternalFuncShowoff WhaleWithFortune: run: whalesay inputs: \u0026quot;{$.Tasks.GenerateFortune.Output}\u0026quot; requires: - GenerateFortune  What you see is the YAML-based workflow definition of the fortunewhale workflow. A workflow consists of multiple tasks, which are steps that it needs to complete. Each task has a unique identifier, such as GenerateFortune, a reference to a Fission function in the run field. Optionally, it can contain inputs which allows you to specify inputs to the task, as well as contain requires which allows you to specify which tasks need to complete before this task can start. Finally, at the top you will find the output field, which specifies the task whose output is used as the workflow\u0026rsquo;s output.\nIn this case, the fortunewhale workflow consists of a sequence of 3 tasks:\nInternalFuncShowoff -\u0026gt; GenerateFortune -\u0026gt; WhaleWithFortune  First, it starts with InternalFuncShowoff by running noop, which is an internal function in the workflow engine. Internal functions are run inside of the workflow engine, which makes them run much faster at the cost of expressiveness and scalability. So typically, light-weight functions, such as logic or control flow operations, are good candidates to be used as internal functions. Besides, a minimal set of predefined internal functions, you can define internal function - there is nothing special about them.\nAfter InternalFuncShowff completes, the GenerateFortune task can start as its requires has been fulfilled. It runs the fortune Fission function, which outputs a random piece of wisdom.\nAfter GenerateFortune completes, the WhaleWithFortune task can start. This task uses a javascript expression in its inputs to reference the output of the GenerateFortune task. In the inputs of a task you can reference anything in the workflow, such as outputs, inputs, and task definitions, or just provide a constant value. The workflow engine invokes the whalesay fission function with as input the piece of wisdom, which outputs the ASCI whale that wraps the phrase.\nFinally, with all tasks completed, the workflow engine uses the top-level output field to fetch the output of the WhaleWithFortune and return it to the user. As the workflow engine adheres to the Fission function specification, a Fission workflow is just another Fission Function. This means that you could use this workflow as a function in the run in other workflows.\nWhat\u0026rsquo;s next? To learn more about the Fission Workflows system and its advanced concepts, see the documentation on Github.\nOr, check out the examples for more example workflows.\nIf something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\n"
},
{
	"uri": "http://fission.io/docs/0.5.0/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://fission.io/docs/0.5.0/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://fission.io/docs/0.5.0/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]